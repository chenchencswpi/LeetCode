Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

这道题和摆渡翁带你刷leetcode第105题是一个意思。题目给定了一个二叉树的中序遍历和后序遍历，让我们把二叉树构造出来。
中序遍历是先访问左孩子，然后访问自己，再访问右孩子。后序遍历是先访问左孩子，然后右孩子，最后访问自己。举个栗子：
         1
        / \
       2   5
      / \   \
     3   4   6
中序遍历是3，2，4，1，5，6，后序遍历是3，4，2，6，5，1.我们可以看到，在后续遍历当中，每个子树的根节点总会是出现在
最后一位。那么怎么构建这个二叉树呢？我们每次先去后序遍历里确定根节点，然后在中序遍历中找到根节点的位置，那么根节点的
左子树就在中序遍历的开头到根节点位置-1，右子树就在中序遍历根节点位置+1到终点。也就是说，用后序遍历不断确定每个子树的
根节点，然后用中序遍历不断的narrow down左子树和右子树的取值区间。例如上面的例子，我们先确定根节点为1，那么在中序遍
历中找到了1后，1的左子树有3个节点，分别是3，2，4，那么在这个左子树里面，2又是根节点...以此类推。好了大家看代码：

//插入方法buildTree(), constructNode(), findIndex()